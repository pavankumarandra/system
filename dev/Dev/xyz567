elif service_int == 0x28:
    if subfunc != "":
        try:
            subfunc_clean = subfunc.strip()
            control_type = int(subfunc_clean, 16)

            # Use communication_type from .txt if provided
            if communication_type:
                try:
                    communication_type_int = int(communication_type, 16)
                except ValueError:
                    logging.warning(f"{tc_id} - Invalid communication_type '{communication_type}', defaulting to control_type")
                    communication_type_int = control_type
            else:
                communication_type_int = control_type  # Fallback

            raw_request = bytes([0x28, control_type, communication_type_int])
            logging.info(f"{tc_id} - {step_desc}: Sending raw request {raw_request.hex().upper()}")
            client.conn.send(raw_request)
            response = wait_for_final_response(client, tc_id, step_desc)

        except ValueError:
            logging.error(f"{tc_id} - Invalid subfunction format: '{subfunc}'")
        except Exception as e:
            logging.error(f"{tc_id} - Error sending CommunicationControl raw request: {e}")

    elif subfunc == "":
        subfunc_clean = subfunc.strip()
        subfunc_bytes = bytes.fromhex(subfunc_clean) if subfunc_clean else b''
        expected_bytes = [int(b, 16) for b in expected.strip().split()]
        raw_request = bytearray([service_int]) + subfunc_bytes
        client.conn.send(raw_request)
        response_data = client.conn.wait_frame(timeout=2)
